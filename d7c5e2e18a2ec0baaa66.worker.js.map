{"version":3,"sources":["../webpack/bootstrap","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js","logic.js","sim.worker.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","_arrayLikeToArray","arr","len","length","arr2","Array","_createForOfIteratorHelper","iterator","isArray","minLen","toString","slice","constructor","from","test","F","done","e","_e","f","TypeError","it","err","normalCompletion","didErr","step","next","_e2","_defineProperty","obj","configurable","writable","ownKeys","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","apply","_objectSpread2","target","arguments","source","forEach","getOwnPropertyDescriptors","defineProperties","nextOutputFunctions","and","gate","state","getInputs","every","x","or","some","xor","constant","led","text","buffer","switch","Boolean","getUserInput","sender","receiver","circuit","gates","find","type","label","findSender","mux","inputs","index","reduce","Number","demux","outputs","fill","sevenSegment","srLatch","getOutputs","q","dLatch","dFlipFlop","cPrev","prevState","srDFlipFlop","nextState","nextOutputs","id","isInverted","assign","pin","map","connections","callback","handle","startSimulation","initialState","Error","logic","setInterval","getState","stopSimulation","clearInterval","setUserInput"],"mappings":"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","file":"d7c5e2e18a2ec0baaa66.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/fluxlogic/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nexport default function _createForOfIteratorHelper(o) {\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = unsupportedIterableToArray(o))) {\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var it,\n      normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","import arrayLikeToArray from \"./arrayLikeToArray\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import defineProperty from \"./defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}","import packageJson from '../package.json'\n\n/*\n * An object mapping gate types to functions.\n */\nconst nextOutputFunctions = {\n  and: (gate, state) => [getInputs(gate, state).every((x) => x)],\n  or: (gate, state) => [getInputs(gate, state).some((x) => x)],\n  xor: (gate, state) => [\n    getInputs(gate, state).filter((x) => x).length % 2 !== 0\n  ],\n  constant: (gate, state) => [gate.value],\n  led: () => [],\n  text: () => [],\n  buffer: (gate, state) => getInputs(gate, state),\n  switch: (gate, state) => [Boolean(getUserInput(gate, state))],\n  sender: () => [],\n  receiver: (gate, state, circuit) => getInputs(\n    findSender(gate, circuit),\n    state\n  ),\n  mux: (gate, state) => {\n    const inputs = getInputs(gate, state)\n    const index = inputs\n      .slice(0, gate.n)\n      .reduce((t, c, i) => t + Number(c) * (1 << i), 0)\n    return [inputs[gate.n + index]]\n  },\n  demux: (gate, state) => {\n    const inputs = getInputs(gate, state)\n    const index = inputs\n      .slice(0, gate.n)\n      .reduce((t, c, i) => t + Number(c) * (1 << i), 0)\n    const outputs = new Array(1 << gate.n)\n    outputs.fill(false)\n    outputs[index] = inputs[gate.n]\n    return outputs\n  },\n  sevenSegment: () => [],\n  srLatch: (gate, state) => {\n    const inputs = getInputs(gate, state)\n    const outputs = getOutputs(gate, state)\n\n    const s = inputs[2]\n    const e = inputs[1]\n    const r = inputs[0]\n\n    const q = outputs[1]\n\n    if (e && s && !r) {\n      return [false, true]\n    } else if (e && !s && r) {\n      return [true, false]\n    } else {\n      return [!q, q]\n    }\n  },\n  dLatch: (gate, state) => {\n    const inputs = getInputs(gate, state)\n    const outputs = getOutputs(gate, state)\n\n    const d = inputs[1]\n    const e = inputs[0]\n\n    const q = outputs[1]\n    if (e) {\n      return [!d, d]\n    } else {\n      return [!q, q]\n    }\n  },\n  dFlipFlop: (gate, state) => {\n    const inputs = getInputs(gate, state)\n    const outputs = getOutputs(gate, state)\n\n    const cPrev = state.prevState && getInputs(gate, state.prevState)[0]\n    const c = inputs[0]\n    const d = inputs[1]\n\n    const q = outputs[1]\n\n    const isRisingEdge = cPrev !== c && c === true\n\n    if (isRisingEdge) {\n      return [!d, d]\n    } else {\n      return [!q, q]\n    }\n  },\n  srDFlipFlop: (gate, state) => {\n    const inputs = getInputs(gate, state)\n    const outputs = getOutputs(gate, state)\n\n    const r = inputs[0]\n    const cPrev = state.prevState && getInputs(gate, state.prevState)[1]\n    const c = inputs[1]\n    const d = inputs[2]\n    const s = inputs[3]\n\n    const q = outputs[1]\n\n    const isRisingEdge = cPrev !== c && c === true\n\n    /*\n     * Truth table taken from:\n     * https://en.wikipedia.org/wiki/Flip-flop_(electronics)\n     */\n    if (s && !r) {\n      return [false, true]\n    } else if (!s && r) {\n      return [true, false]\n    } else if (s && r) {\n      return [true, true]\n    } else if (isRisingEdge) {\n      return [!d, d]\n    } else {\n      return [!q, q]\n    }\n  }\n}\n\n/** Connect to logic pins by a wire. */\nfunction connect (a, b) {\n  a.connections.push(b.id)\n  b.connections.push(a.id)\n}\n\n/**\n * Creates a circuit with the given gates.\n */\nfunction circuit (gates) {\n  return {\n    gates\n  }\n}\n\n/**\n * Creates a logic pin. A pin may be inverted by setting its isInverted field.\n */\nfunction pin () {\n  return {\n    id: nextId(),\n    connections: []\n  }\n}\n\n/** Creates an and gate. */\nfunction andGate () {\n  return {\n    id: nextId(),\n    type: 'and',\n    inputs: [pin(), pin()],\n    outputs: Object.seal([pin()])\n  }\n}\n\n/** Creates an or gate. */\nfunction orGate () {\n  return {\n    id: nextId(),\n    type: 'or',\n    inputs: [pin(), pin()],\n    outputs: Object.seal([pin()])\n  }\n}\n\n/** Creates an xor gate. */\nfunction xorGate () {\n  return {\n    id: nextId(),\n    type: 'xor',\n    inputs: [pin(), pin()],\n    outputs: Object.seal([pin()])\n  }\n}\n\n/** Creates a constant gate (for simulating ground or 1). */\nfunction constantGate (value) {\n  return {\n    id: nextId(),\n    type: 'constant',\n    inputs: Object.seal([]),\n    outputs: Object.seal([pin()]),\n    value: value || false\n  }\n}\n\n/** Creates a switch gate that the user can interact with. */\nfunction switchGate () {\n  return {\n    id: nextId(),\n    type: 'switch',\n    inputs: Object.seal([]),\n    outputs: Object.seal([pin()])\n  }\n}\n\n/** Creates an LED. */\nfunction led () {\n  return {\n    id: nextId(),\n    type: 'led',\n    inputs: Object.seal([pin()]),\n    outputs: Object.seal([])\n  }\n}\n\n/** Creates a buffer (a gate that simply passes its input to its output). */\nfunction buffer () {\n  return {\n    id: nextId(),\n    type: 'buffer',\n    inputs: Object.seal([pin()]),\n    outputs: Object.seal([pin()])\n  }\n}\n\n/**\n * Creates a sender with the given label. A receiver with the same label will\n * receive the inputs of the sender.\n */\nfunction sender (label) {\n  return {\n    id: nextId(),\n    type: 'sender',\n    label: label || 'A',\n    inputs: Object.seal([pin()]),\n    outputs: Object.seal([])\n  }\n}\n\n/**\n * Creates a receiver with the given label. The receiver will have the same\n * input values as the sender with the given label.\n */\nfunction receiver (label) {\n  return {\n    id: nextId(),\n    type: 'receiver',\n    label: label || 'A',\n    inputs: Object.seal([]),\n    outputs: Object.seal([pin()])\n  }\n}\n\n/**\n * Creates a multiplexor with the given number of select lines. The first n\n * items in gate.inputs are the select lines (least significant bit first), the\n * next n^2 are the data lines. The number of select lines, n, is stored in the\n * n field of the returned object.\n */\nfunction mux (n) {\n  const inputs = []\n  for (let i = 0; i < n; i++) {\n    inputs.push(pin())\n  }\n  for (let i = 0; i < (1 << n); i++) {\n    inputs.push(pin())\n  }\n  return {\n    id: nextId(),\n    type: 'mux',\n    n,\n    inputs: Object.seal(inputs),\n    outputs: Object.seal([pin()])\n  }\n}\n\n/**\n * Creates a demultiplexor with the given number of select lines. The first n\n * items in gates.inputs are the selectl ines (least significant bit first),\n * followed by the data line. The number of select lines, n, is stored in the n\n * field of the returned object. The returned gate has 2^n outputs.\n */\nfunction demux (n) {\n  const inputs = [pin()]\n  const outputs = []\n  for (let i = 0; i < n; i++) {\n    inputs.push(pin())\n  }\n  for (let i = 0; i < (1 << n); i++) {\n    outputs.push(pin())\n  }\n  return {\n    id: nextId(),\n    type: 'demux',\n    n,\n    inputs: Object.seal(inputs),\n    outputs: Object.seal(outputs)\n  }\n}\n\nfunction sevenSegment (n) {\n  return {\n    id: nextId(),\n    type: 'sevenSegment',\n    inputs: Object.seal([\n      pin(),\n      pin(),\n      pin(),\n      pin()\n    ]),\n    outputs: Object.seal([])\n  }\n}\n\n/**\n * Creates a gated SR-latch component, where inputs[0] is R, inputs[1] is E,\n * inputs[2] is S, outputs[0] is !Q, outputs[1] is Q.\n */\nfunction srLatch () {\n  return {\n    id: nextId(),\n    type: 'srLatch',\n    inputs: Object.seal([\n      pin(),\n      pin(),\n      pin()\n    ]),\n    outputs: Object.seal([\n      pin(),\n      pin()\n    ])\n  }\n}\n\n/**\n * Creates a D-latch, where inputs[0] is E, inputs[1] is D, outputs[0] is !Q,\n * outputs[1] is Q.\n */\nfunction dLatch () {\n  return {\n    id: nextId(),\n    type: 'dLatch',\n    inputs: Object.seal([\n      pin(),\n      pin()\n    ]),\n    outputs: Object.seal([\n      pin(),\n      pin()\n    ])\n  }\n}\n\n/**\n * Creates a D-flip-flop, where inputs[0] is C, inputs[1] is D.\n */\nfunction dFlipFlop () {\n  return {\n    id: nextId(),\n    type: 'dFlipFlop',\n    inputs: Object.seal([\n      pin(),\n      pin()\n    ]),\n    outputs: Object.seal([\n      pin(),\n      pin()\n    ])\n  }\n}\n\n/**\n * Creates a D-flip-flop with S and R pins, where inputs[0] is R, inputs[1] is\n * C, inputs[2] is D, inputs[3] is S.\n */\nfunction srDFlipFlop () {\n  return {\n    id: nextId(),\n    type: 'srDFlipFlop',\n    inputs: Object.seal([\n      pin(),\n      pin(),\n      pin(),\n      pin()\n    ]),\n    outputs: Object.seal([\n      pin(),\n      pin()\n    ])\n  }\n}\n\n/**\n * Creates a text component, which displays text on the screen. It has a\n * text field, which contains the text to be displayed.\n */\nfunction text (string) {\n  return {\n    id: nextId(),\n    type: 'text',\n    inputs: Object.seal([]),\n    outputs: Object.seal([]),\n    text: string,\n    width: 2,\n    height: 0.5\n  }\n}\n\n/**\n * Computes a state object to represent the current state of the simulation for\n * the given circuit. If prevState is passed, returns the next state after the\n * given state.\n *\n * The state object is an object containing an outputs field, which is an object\n * that maps each pin ID to a boolean value. For example, if a pin with ID 2 has\n * an output of true, the state object would look something like this:\n * { outputs: { 2: true } }\n *\n * To calculate the inputs and outputs of individual gates, the getInputs and\n * getOutputs helper functions can be used.\n *\n * The input from the user (for example, whether a switch is switched or not) is\n * stored in the inputs field, that maps a gate ID to a user input object. The\n * format of the input depends on the gate itself.\n *\n * The state also keeps track of its state in the previous simulation frame,\n * stored in the prevState field of the state. This is only used in the flip\n * flop components to keep track of edge triggered events.\n */\nfunction nextState (circuit, prevState) {\n  const state = {\n    outputs: {},\n    inputs: {}\n  }\n\n  /* Copy the previous state if it's provided. */\n  if (prevState) {\n    state.prevState = { ...prevState }\n    delete state.prevState.prevState\n  }\n\n  if (prevState) {\n    for (const gate of circuit.gates) {\n      /* Calculate the next output. */\n      const nextOutputs = nextOutputFunctions[gate.type](\n        gate,\n        prevState,\n        circuit\n      )\n\n      for (let i = 0; i < nextOutputs.length; i++) {\n        state.outputs[gate.outputs[i].id] = (\n          nextOutputs[i] ^ gate.outputs[i].isInverted) === 1\n      }\n    }\n\n    Object.assign(state.inputs, prevState.inputs)\n  } else {\n    /* Initialize all outputs to false. */\n    for (const gate of circuit.gates) {\n      for (const pin of gate.outputs) {\n        state.outputs[pin.id] = false\n      }\n    }\n  }\n\n  return state\n}\n\n/**\n * Returns the sender gate for the given receiver gate.\n */\nfunction findSender (receiver, circuit) {\n  return circuit.gates.find(\n    (gate) => gate.type === 'sender' && gate.label === receiver.label\n  )\n}\n\n/**\n * Returns a list of input booleans for the gate given the current simulation\n * state.\n */\nfunction getInputs (gate, state) {\n  return gate.inputs\n    .map((pin) => (state.outputs[pin.connections[0]] ^ pin.isInverted) === 1)\n}\n\n/**\n * Returns a list of output booleans for the gate given the current simulation\n * state.\n */\nfunction getOutputs (gate, state) {\n  return gate.outputs.map((pin) => state.outputs[pin.id])\n}\n\n/**\n * Returns the user input for the gate given the current simulation state.\n */\nfunction getUserInput (gate, state) {\n  return state.inputs[gate.id]\n}\n\n/**\n * Sets the user input for the gate for the current simulation state.\n */\nfunction setUserInput (gate, state, value) {\n  state.inputs[gate.id] = value\n}\n\n/**\n * Skip forward n simulation states given a circuit, n, and the (optional)\n * current state. This function simply calls nextState(circuit, state) n times.\n */\nfunction fastForward (circuit, n, state) {\n  for (let i = 0; i < n; i++) {\n    state = nextState(circuit, state)\n  }\n  return state\n}\n\n/*\n * Function to return a unique id. This should only be used within this JS file.\n * The ID wraps around to 0 once Number.MAX_SAFE_INTEGER is reached. This is\n * assumed to be okay since Number.MAX_SAFE_INTEGER is so large.\n */\nlet currentId = 0\nfunction nextId () {\n  if (currentId >= Number.MAX_SAFE_INTEGER) {\n    currentId = 0\n  }\n\n  return currentId++\n}\n\n/*\n * This function renumbers the IDs of the given circuit so that there are no\n * collisions. This should be called any time a circuit is loaded to avoid\n * collisions. It returns the circuit.\n */\nfunction renumber (circuit) {\n  const clone = { ...circuit }\n  let maxId = currentId\n\n  const calcNewId = (id) => currentId < (Number.MAX_SAFE_INTEGER - id)\n    ? id + currentId\n    : (id - Number.MAX_SAFE_INTEGER) + currentId\n\n  const updateId = (object) => {\n    const clone = {\n      ...object,\n      id: calcNewId(object.id)\n    }\n    if (clone.id > maxId) {\n      maxId = clone.id\n    }\n\n    if (clone.connections) {\n      clone.connections = clone.connections.map(calcNewId)\n    }\n    return clone\n  }\n\n  clone.gates = clone.gates.map((gate) => {\n    const r = updateId(gate)\n    r.inputs = r.inputs.map(updateId)\n    r.outputs = r.outputs.map(updateId)\n    return r\n  })\n\n  currentId = maxId + 1\n\n  return clone\n}\n\n/**\n * Create an object containing the IDs of all valid pins for the given gates.\n */\nconst getValidPins = (gates) => (\n  Object.fromEntries(gates.reduce(\n    (t, gate) => t.concat(\n      gate.inputs.map((pin) => pin.id),\n      gate.outputs.map((pin) => pin.id)),\n    []\n  ).map((id) => [id, true]))\n)\n\n/**\n * Returns a new list of gates from the given list of gates with the\n * connections to invalid pins removed.\n */\nconst removeInvalidConnections = (gates) => {\n  const validPins = getValidPins(gates)\n\n  /* Remove all connections that point to a deleted pin. */\n  return gates.map((gate) => {\n    const gateClone = { ...gate }\n    const updatePin = (pin) => {\n      return {\n        ...pin,\n        connections: pin.connections.filter((id) => validPins[id])\n      }\n    }\n\n    gateClone.inputs = gateClone.inputs.map(updatePin)\n    gateClone.outputs = gateClone.outputs.map(updatePin)\n    return gateClone\n  })\n}\n\n/**\n * Returns a list of all the labels that are used by 2 or more senders in the\n * given list of gates, sorted alphabetically. This is useful as an error check\n * to make sure there are no duplicate senders.\n */\nconst getDuplicateSenderLabels = (gates) => {\n  const senderCounts = {}\n\n  gates.forEach((gate) => {\n    if (gate.type === 'sender') {\n      senderCounts[gate.label] = (senderCounts[gate.label] || 0) + 1\n    }\n  })\n\n  return Object.entries(senderCounts)\n    .filter((x) => x[1] > 1)\n    .map((x) => x[0])\n    .sort()\n}\n\n/**\n * Stores the project in a string. The project can be loaded using the\n * loadProject function.\n */\nconst dumpProject = (circuit, currentPage) => {\n  return JSON.stringify({\n    version: packageJson.version,\n    circuit,\n    currentPage\n  })\n}\n\n/**\n * Loads the project from a string. Returns an object with the circuit in the\n * circuit field, the current page in the currentPage field, and the Flux Logic\n * version in the version field.\n */\nconst loadProject = (data) => {\n  return JSON.parse(data)\n}\n\nexport {\n  /* Simulation. */\n  nextState,\n  getOutputs,\n  getInputs,\n  getUserInput,\n  setUserInput,\n  fastForward,\n\n  /* Circuit creation. */\n  renumber,\n  connect,\n  circuit,\n  andGate,\n  orGate,\n  xorGate,\n  constantGate,\n  switchGate,\n  sender,\n  receiver,\n  led,\n  buffer,\n  pin,\n  mux,\n  demux,\n  sevenSegment,\n  srLatch,\n  dLatch,\n  srDFlipFlop,\n  dFlipFlop,\n  text,\n\n  /* Utils. */\n  removeInvalidConnections,\n  getValidPins,\n  findSender,\n  getDuplicateSenderLabels,\n\n  /* Saving and loading. */\n  loadProject,\n  dumpProject\n}\n","import * as logic from './logic'\n\nlet state = null\nlet callback = null\nlet handle = null\n\nexport function startSimulation (circuit, initialState) {\n  if (!state && !callback && !handle) {\n    state = initialState || logic.nextState(circuit)\n    callback = () => {\n      state = logic.nextState(circuit, state)\n    }\n    handle = setInterval(callback, 1)\n  } else {\n    throw new Error('simulation already started')\n  }\n}\n\nexport function getState () {\n  return state\n}\n\nexport function stopSimulation () {\n  clearInterval(handle)\n  state = null\n  callback = null\n  handle = null\n}\n\nexport function setUserInput (gate, value) {\n  logic.setUserInput(gate, state, value)\n}\n"],"sourceRoot":""}